{"ast":null,"code":"import prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism,\n  theme: theme\n};\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function normalizeEmptyLines(line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\nvar appendTypes = function appendTypes(types, add) {\n  var typesSize = types.length;\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\nvar normalizeTokens = function normalizeTokens(tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\nvar themeToDict = function themeToDict(theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n  return target;\n}\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n      len = arguments.length;\n    while (len--) args[len] = arguments[len];\n    Component.apply(this, args);\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n      var themeDict = this$1.getThemeDict(this$1.props);\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n      if (key !== undefined) {\n        output.key = key;\n      }\n      if (className) {\n        output.className += \" \" + className;\n      }\n      return output;\n    });\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n      if (key !== undefined) {\n        output.key = key;\n      }\n      if (className) {\n        output.className += \" \" + className;\n      }\n      return output;\n    });\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n  return Highlight;\n}(Component);\nexport default Highlight;\nexport { defaultProps };","map":{"version":3,"names":["prism","default","Prism","theme","Component","defaultProps","_defineProperty","obj","key","value","Object","defineProperty","enumerable","configurable","writable","_extends","assign","target","i","arguments","length","source","prototype","hasOwnProperty","call","apply","newlineRe","normalizeEmptyLines","line","push","types","content","empty","appendTypes","add","typesSize","concat","normalizeTokens","tokens","typeArrStack","tokenArrStack","tokenArrIndexStack","tokenArrSizeStack","stackIndex","currentLine","acc","tokenArr","token","type","alias","splitByNewlines","split","newlineCount","i$1","pop","themeToDict","language","plain","base","create","themeDict","styles","reduce","themeEntry","languages","style","includes","forEach","accStyle","root","backgroundColor","objectWithoutProperties","exclude","k","indexOf","Highlight","this$1","args","len","props","undefined","prevTheme","prevLanguage","ref","className","rest$1","rest","output","getThemeDict","display","baseStyle","typeStyles","map","join","children","getStyleForToken","code","grammar","env","hooks","run","tokenize","__proto__","constructor","render","mixedTokens","getLineProps","getTokenProps"],"sources":["/home/runner/work/gitgame/gitgame/client/node_modules/prism-react-renderer/dist/index.js"],"sourcesContent":["import prism from '../prism/index.js';\nexport { default as Prism } from '../prism/index.js';\nimport theme from '../themes/duotoneDark';\nimport { Component } from 'react';\n\nvar defaultProps = {\n  // $FlowFixMe\n  Prism: prism,\n  theme: theme\n};\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar newlineRe = /\\r\\n|\\r|\\n/; // Empty lines need to contain a single empty token, denoted with { empty: true }\n\nvar normalizeEmptyLines = function (line) {\n  if (line.length === 0) {\n    line.push({\n      types: [\"plain\"],\n      content: \"\\n\",\n      empty: true\n    });\n  } else if (line.length === 1 && line[0].content === \"\") {\n    line[0].content = \"\\n\";\n    line[0].empty = true;\n  }\n};\n\nvar appendTypes = function (types, add) {\n  var typesSize = types.length;\n\n  if (typesSize > 0 && types[typesSize - 1] === add) {\n    return types;\n  }\n\n  return types.concat(add);\n}; // Takes an array of Prism's tokens and groups them by line, turning plain\n// strings into tokens as well. Tokens can become recursive in some cases,\n// which means that their types are concatenated. Plain-string tokens however\n// are always of type \"plain\".\n// This is not recursive to avoid exceeding the call-stack limit, since it's unclear\n// how nested Prism's tokens can become\n\n\nvar normalizeTokens = function (tokens) {\n  var typeArrStack = [[]];\n  var tokenArrStack = [tokens];\n  var tokenArrIndexStack = [0];\n  var tokenArrSizeStack = [tokens.length];\n  var i = 0;\n  var stackIndex = 0;\n  var currentLine = [];\n  var acc = [currentLine];\n\n  while (stackIndex > -1) {\n    while ((i = tokenArrIndexStack[stackIndex]++) < tokenArrSizeStack[stackIndex]) {\n      var content = void 0;\n      var types = typeArrStack[stackIndex];\n      var tokenArr = tokenArrStack[stackIndex];\n      var token = tokenArr[i]; // Determine content and append type to types if necessary\n\n      if (typeof token === \"string\") {\n        types = stackIndex > 0 ? types : [\"plain\"];\n        content = token;\n      } else {\n        types = appendTypes(types, token.type);\n\n        if (token.alias) {\n          types = appendTypes(types, token.alias);\n        }\n\n        content = token.content;\n      } // If token.content is an array, increase the stack depth and repeat this while-loop\n\n\n      if (typeof content !== \"string\") {\n        stackIndex++;\n        typeArrStack.push(types);\n        tokenArrStack.push(content);\n        tokenArrIndexStack.push(0);\n        tokenArrSizeStack.push(content.length);\n        continue;\n      } // Split by newlines\n\n\n      var splitByNewlines = content.split(newlineRe);\n      var newlineCount = splitByNewlines.length;\n      currentLine.push({\n        types: types,\n        content: splitByNewlines[0]\n      }); // Create a new line for each string on a new line\n\n      for (var i$1 = 1; i$1 < newlineCount; i$1++) {\n        normalizeEmptyLines(currentLine);\n        acc.push(currentLine = []);\n        currentLine.push({\n          types: types,\n          content: splitByNewlines[i$1]\n        });\n      }\n    } // Decreate the stack depth\n\n\n    stackIndex--;\n    typeArrStack.pop();\n    tokenArrStack.pop();\n    tokenArrIndexStack.pop();\n    tokenArrSizeStack.pop();\n  }\n\n  normalizeEmptyLines(currentLine);\n  return acc;\n};\n\nvar themeToDict = function (theme, language) {\n  var plain = theme.plain; // $FlowFixMe\n\n  var base = Object.create(null);\n  var themeDict = theme.styles.reduce(function (acc, themeEntry) {\n    var languages = themeEntry.languages;\n    var style = themeEntry.style;\n\n    if (languages && !languages.includes(language)) {\n      return acc;\n    }\n\n    themeEntry.types.forEach(function (type) {\n      // $FlowFixMe\n      var accStyle = _extends({}, acc[type], style);\n\n      acc[type] = accStyle;\n    });\n    return acc;\n  }, base); // $FlowFixMe\n\n  themeDict.root = plain; // $FlowFixMe\n\n  themeDict.plain = _extends({}, plain, {\n    backgroundColor: null\n  });\n  return themeDict;\n};\n\nfunction objectWithoutProperties(obj, exclude) {\n  var target = {};\n\n  for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k];\n\n  return target;\n}\n\nvar Highlight = /*@__PURE__*/function (Component) {\n  function Highlight() {\n    var this$1 = this;\n    var args = [],\n        len = arguments.length;\n\n    while (len--) args[len] = arguments[len];\n\n    Component.apply(this, args);\n\n    _defineProperty(this, \"getThemeDict\", function (props) {\n      if (this$1.themeDict !== undefined && props.theme === this$1.prevTheme && props.language === this$1.prevLanguage) {\n        return this$1.themeDict;\n      }\n\n      this$1.prevTheme = props.theme;\n      this$1.prevLanguage = props.language;\n      var themeDict = props.theme ? themeToDict(props.theme, props.language) : undefined;\n      return this$1.themeDict = themeDict;\n    });\n\n    _defineProperty(this, \"getLineProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"line\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token-line\",\n        style: undefined,\n        key: undefined\n      });\n\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict !== undefined) {\n        output.style = themeDict.plain;\n      }\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"getStyleForToken\", function (ref) {\n      var types = ref.types;\n      var empty = ref.empty;\n      var typesSize = types.length;\n      var themeDict = this$1.getThemeDict(this$1.props);\n\n      if (themeDict === undefined) {\n        return undefined;\n      } else if (typesSize === 1 && types[0] === \"plain\") {\n        return empty ? {\n          display: \"inline-block\"\n        } : undefined;\n      } else if (typesSize === 1 && !empty) {\n        return themeDict[types[0]];\n      }\n\n      var baseStyle = empty ? {\n        display: \"inline-block\"\n      } : {}; // $FlowFixMe\n\n      var typeStyles = types.map(function (type) {\n        return themeDict[type];\n      });\n      return Object.assign.apply(Object, [baseStyle].concat(typeStyles));\n    });\n\n    _defineProperty(this, \"getTokenProps\", function (ref) {\n      var key = ref.key;\n      var className = ref.className;\n      var style = ref.style;\n      var token = ref.token;\n      var rest$1 = objectWithoutProperties(ref, [\"key\", \"className\", \"style\", \"token\"]);\n      var rest = rest$1;\n\n      var output = _extends({}, rest, {\n        className: \"token \" + token.types.join(\" \"),\n        children: token.content,\n        style: this$1.getStyleForToken(token),\n        key: undefined\n      });\n\n      if (style !== undefined) {\n        output.style = output.style !== undefined ? _extends({}, output.style, style) : style;\n      }\n\n      if (key !== undefined) {\n        output.key = key;\n      }\n\n      if (className) {\n        output.className += \" \" + className;\n      }\n\n      return output;\n    });\n\n    _defineProperty(this, \"tokenize\", function (Prism, code, grammar, language) {\n      var env = {\n        code: code,\n        grammar: grammar,\n        language: language,\n        tokens: []\n      };\n      Prism.hooks.run(\"before-tokenize\", env);\n      var tokens = env.tokens = Prism.tokenize(env.code, env.grammar, env.language);\n      Prism.hooks.run(\"after-tokenize\", env);\n      return tokens;\n    });\n  }\n\n  if (Component) Highlight.__proto__ = Component;\n  Highlight.prototype = Object.create(Component && Component.prototype);\n  Highlight.prototype.constructor = Highlight;\n\n  Highlight.prototype.render = function render() {\n    var ref = this.props;\n    var Prism = ref.Prism;\n    var language = ref.language;\n    var code = ref.code;\n    var children = ref.children;\n    var themeDict = this.getThemeDict(this.props);\n    var grammar = Prism.languages[language];\n    var mixedTokens = grammar !== undefined ? this.tokenize(Prism, code, grammar, language) : [code];\n    var tokens = normalizeTokens(mixedTokens);\n    return children({\n      tokens: tokens,\n      className: \"prism-code language-\" + language,\n      style: themeDict !== undefined ? themeDict.root : {},\n      getLineProps: this.getLineProps,\n      getTokenProps: this.getTokenProps\n    });\n  };\n\n  return Highlight;\n}(Component);\n\nexport default Highlight;\nexport { defaultProps };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}