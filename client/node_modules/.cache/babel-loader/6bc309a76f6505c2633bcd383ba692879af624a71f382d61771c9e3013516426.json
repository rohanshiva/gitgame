{"ast":null,"code":"/*\ntodo(Ramko9999): Add tests for the below functions\n*/export function getViewportBounds(element){var _element$getBoundingC=element.getBoundingClientRect(),x=_element$getBoundingC.x,y=_element$getBoundingC.y,width=_element$getBoundingC.width,height=_element$getBoundingC.height;return{topLeft:{x:x,y:y},bottomRight:{x:x+width,y:y+height},width:width,height:height};}export function anchorViewportBoundsRelativeTo(bounds,anchor){return{topLeft:{x:bounds.topLeft.x-anchor.topLeft.x,y:bounds.topLeft.y-anchor.topLeft.y},bottomRight:{x:bounds.bottomRight.x-anchor.topLeft.x,y:bounds.bottomRight.y-anchor.topLeft.y},width:bounds.width,height:bounds.height};}export function mergeViewportBounds(bounds1,bounds2){var topLeft={x:Math.min(bounds1.topLeft.x,bounds2.topLeft.x),y:Math.min(bounds1.topLeft.y,bounds2.topLeft.y)};var bottomRight={x:Math.max(bounds1.bottomRight.x,bounds2.bottomRight.x),y:Math.max(bounds1.bottomRight.y,bounds2.bottomRight.y)};return{topLeft:topLeft,bottomRight:bottomRight,width:bottomRight.x-topLeft.x,height:bottomRight.y-topLeft.y};}/*\nComputes the minimum amount to scroll in the Y axis to display the scrollTarget \n*/export function computeLazyScrollYAxisOptions(currentViewport,scrollTarget,maxScrollPadding){var scrollPadding=Math.min(Math.max(Math.floor((currentViewport.height-scrollTarget.height)/2),0),maxScrollPadding);var desiredViewportYBounds={start:currentViewport.topLeft.y+scrollPadding,end:currentViewport.bottomRight.y-scrollPadding};var isTargetBoundWithinDesiredView=desiredViewportYBounds.start<=scrollTarget.topLeft.y&&desiredViewportYBounds.end>=scrollTarget.bottomRight.y;if(!isTargetBoundWithinDesiredView){if(scrollTarget.topLeft.y<desiredViewportYBounds.start||scrollTarget.height>=currentViewport.height){return{top:scrollTarget.topLeft.y-desiredViewportYBounds.start,behavior:\"smooth\"};}else{return{top:scrollTarget.bottomRight.y-desiredViewportYBounds.end,behavior:\"smooth\"};}}// no need to scroll since the scrollTarget is already within our desired viewport Y range\nreturn{};}","map":{"version":3,"names":["getViewportBounds","element","_element$getBoundingC","getBoundingClientRect","x","y","width","height","topLeft","bottomRight","anchorViewportBoundsRelativeTo","bounds","anchor","mergeViewportBounds","bounds1","bounds2","Math","min","max","computeLazyScrollYAxisOptions","currentViewport","scrollTarget","maxScrollPadding","scrollPadding","floor","desiredViewportYBounds","start","end","isTargetBoundWithinDesiredView","top","behavior"],"sources":["/home/runner/work/gitgame/gitgame/client/src/components/editor/Util.ts"],"sourcesContent":["export interface ViewportBounds {\n  topLeft: {\n    x: number;\n    y: number;\n  };\n  bottomRight: {\n    x: number;\n    y: number;\n  };\n  width: number;\n  height: number;\n}\n\n/*\ntodo(Ramko9999): Add tests for the below functions\n*/\n\nexport function getViewportBounds(element: HTMLElement): ViewportBounds {\n  const { x, y, width, height } = element.getBoundingClientRect();\n  return {\n    topLeft: { x, y },\n    bottomRight: {\n      x: x + width,\n      y: y + height,\n    },\n    width,\n    height,\n  };\n}\n\nexport function anchorViewportBoundsRelativeTo(\n  bounds: ViewportBounds,\n  anchor: ViewportBounds\n): ViewportBounds {\n  return {\n    topLeft: {\n      x: bounds.topLeft.x - anchor.topLeft.x,\n      y: bounds.topLeft.y - anchor.topLeft.y,\n    },\n    bottomRight: {\n      x: bounds.bottomRight.x - anchor.topLeft.x,\n      y: bounds.bottomRight.y - anchor.topLeft.y,\n    },\n    width: bounds.width,\n    height: bounds.height,\n  };\n}\n\nexport function mergeViewportBounds(\n  bounds1: ViewportBounds,\n  bounds2: ViewportBounds\n) {\n  const topLeft = {\n    x: Math.min(bounds1.topLeft.x, bounds2.topLeft.x),\n    y: Math.min(bounds1.topLeft.y, bounds2.topLeft.y),\n  };\n\n  const bottomRight = {\n    x: Math.max(bounds1.bottomRight.x, bounds2.bottomRight.x),\n    y: Math.max(bounds1.bottomRight.y, bounds2.bottomRight.y),\n  };\n\n  return {\n    topLeft,\n    bottomRight,\n    width: bottomRight.x - topLeft.x,\n    height: bottomRight.y - topLeft.y,\n  };\n}\n\n/*\nComputes the minimum amount to scroll in the Y axis to display the scrollTarget \n*/\nexport function computeLazyScrollYAxisOptions(\n  currentViewport: ViewportBounds,\n  scrollTarget: ViewportBounds,\n  maxScrollPadding: number\n): ScrollToOptions {\n  const scrollPadding = Math.min(\n    Math.max(Math.floor((currentViewport.height - scrollTarget.height) / 2), 0),\n    maxScrollPadding\n  );\n\n  const desiredViewportYBounds = {\n    start: currentViewport.topLeft.y + scrollPadding,\n    end: currentViewport.bottomRight.y - scrollPadding,\n  };\n\n  const isTargetBoundWithinDesiredView =\n    desiredViewportYBounds.start <= scrollTarget.topLeft.y &&\n    desiredViewportYBounds.end >= scrollTarget.bottomRight.y;\n\n  if (!isTargetBoundWithinDesiredView) {\n    if (\n      scrollTarget.topLeft.y < desiredViewportYBounds.start ||\n      scrollTarget.height >= currentViewport.height\n    ) {\n      return {\n        top: scrollTarget.topLeft.y - desiredViewportYBounds.start,\n        behavior: \"smooth\",\n      };\n    } else {\n      return {\n        top: scrollTarget.bottomRight.y - desiredViewportYBounds.end,\n        behavior: \"smooth\",\n      };\n    }\n  }\n\n  // no need to scroll since the scrollTarget is already within our desired viewport Y range\n  return {};\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}